# 第一阶段：井字棋

## 画棋盘 (PB.c)
## 走子 (CL.c, PC.c)
## 判断获胜

~~1. 每个点容纳线头~~\
~~2. 线头指向线尾~~\
~~3. 线头容纳长度~~

1. 三维数组储存数据
2. 每次落子判断变化
3. 统计对应行的子数

# 第二阶段：五子棋

## 照搬
1. 把所有常量规范
2. 瞎玩了几把好像没问题
### 其实问题很多
1. 五子棋可能出现间四，要防止间点的分被算错。
2. 许多孤子围绕的中心会被算很多分
## 自动对局
### 第一版就先只实现计分并从最有价值的点里随机摇一个就好
1. 通过递归?实现了统计特定行的子数却没有顺便给个分，尴尬
<!-- ## 优化
1. 记得要优化CountScore的逻辑
2. 将落子处附近定义为热点地区，热度会衰退 -->
### 第二版开始用递归写DFS
1. 通过递归?实现了统计八方的价值
2. 利用返回值进行大小值搜索并剪枝：返回改变量并通过对黑分取相反数得到负极大值
3. 优化寻点法……以后再说吧
4. 必须给间点另外写一个函数算分
### DFS基本写成，附带有AB剪枝(分支)、胜利剪枝(层数)
1. 预计用插值优化寻点法
2. 拆分一下Cover文件
3. ~~绝杀棋算法会放弃抵抗，怎么修好呢……~~\
如果被绝杀就返回最后的一个节点
4. ![点的转换关系](5in1row\图片1.png)

# 收获
1. 一定！务必！切记！要保证一切！所有！任何！情况下函数都有合法的返回值！！！